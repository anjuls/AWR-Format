var dbStatDefs = new Array();

dbStatDefs["background checkpoints completed"]="Number of checkpoints completed by the background process. This statistic is incremented when the background process successfully advances the thread checkpoint.";
dbStatDefs["background checkpoints started"]="Number of checkpoints started by the background process. This statistic can be larger than 'background checkpoints completed' if a new checkpoint overrides an incomplete checkpoint or if a checkpoint is currently under way. This statistic includes only checkpoints of the redo thread. It does not include:Individual file checkpoints for operations such as offline or begin backupForeground (user-requested) checkpoints (for example, performed by ALTER SYSTEM CHECKPOINT LOCAL statements)";
dbStatDefs["background timeouts"]="This is a count of the times where a background process has set an alarm for itself and the alarm has timed out rather than the background process being posted by another process to do some work.";
dbStatDefs["branch node splits"]="Number of times an index branch block was split because of the insertion of an additional value";
dbStatDefs["buffer is not pinned count"]="Number of times a buffer was free when visited. Useful only for internal debugging purposes.";
dbStatDefs["buffer is pinned count"]="Number of times a buffer was pinned when visited. Useful only for internal debugging purposes.";
dbStatDefs["bytes received via SQL*Net from client"]="Total number of bytes received from the client over Oracle Net Services";
dbStatDefs["bytes received via SQL*Net from dblink"]="Total number of bytes received from a database link over Oracle Net Services";
dbStatDefs["bytes sent via SQL*Net to client"]="Total number of bytes sent to the client from the foreground processes";
dbStatDefs["bytes sent via SQL*Net to dblink"]="Total number of bytes sent over a database link";
dbStatDefs["Cached Commit SCN referenced"]="Useful only for internal debugging purposes";
dbStatDefs["calls to get snapshot scn: kcmgss"]="Number of times a snapshot system change number (SCN) was allocated. The SCN is allocated at the start of a transaction.";
dbStatDefs["calls to kcmgas"]="Number of calls to routine kcmgas to get a new SCN";
dbStatDefs["calls to kcmgcs"]="Number of calls to routine kcmgcs to get a current SCN";
dbStatDefs["calls to kcmgrs"]="Number of calls to routine kcsgrs to get a recent SCN";
dbStatDefs["change write time"]="Elapsed redo write time for changes made to CURRENT blocks in 10s of milliseconds.";
dbStatDefs["cleanouts and rollbacks - consistent read gets"]="Number of consistent gets that require both block rollbacks and block cleanouts.See Also: 'consistent gets'";
dbStatDefs["cleanouts only - consistent read gets"]="Number of consistent gets that require only block cleanouts, no rollbacks.See Also: 'consistent gets'";
dbStatDefs["cluster key scan block gets"]="Number of blocks obtained in a cluster scan";
dbStatDefs["cluster key scans"]="Number of cluster scans that were started";
dbStatDefs["cold recycle reads"]="Number of buffers that were read through the least recently used end of the recycle cache with fast aging strategy";
dbStatDefs["commit cleanout failures: block lost"]="Number of times Oracle attempted a cleanout at commit but could not find the correct block due to forced write, replacement, or switch CURRENT";
dbStatDefs["commit cleanout failures: buffer being written"]="Number of times Oracle attempted a cleanout at commit, but the buffer was currently being written";
dbStatDefs["commit cleanout failures: callback failure"]="Number of times the cleanout callback function returns FALSE";
dbStatDefs["commit cleanout failures: cannot pin"]="Total number of times a commit cleanout was performed but failed because the block could not be pinned";
dbStatDefs["commit cleanout failures: hot backup in progress"]="Number of times Oracle attempted block cleanout at commit during hot backup. The image of the block needs to be logged before the buffer can be made dirty.";
dbStatDefs["commit cleanout failures: write disabled"]="Number of times a cleanout block at commit was performed but the writes to the database had been temporarily disabled";
dbStatDefs["commit cleanouts"]="Total number of times the cleanout block at commit function was performed";
dbStatDefs["commit cleanouts successfully completed"]="Number of times the cleanout block at commit function completed successfully";
dbStatDefs["Commit SCN cached"]="Number of times the system change number of a commit operation was cached";
dbStatDefs["consistent changes"]="Number of times a user process has applied rollback entries to perform a consistent read on the blockWork loads that produce a great deal of consistent changes can consume a great deal of resources. The value of this statistic should be small in relation to the 'consistent gets' statistic.";
dbStatDefs["consistent gets"]="Number of times a consistent read was requested for a block.See Also: 'consistent changes' and 'session logical reads' statistics";
dbStatDefs["consistent gets direct"]="Number of times a consistent read was requested for a block bypassing the buffer cache (for example, direct load operation). This is a subset of 'consistent gets' statistics value.";
dbStatDefs["consistent gets from cache"]="Number of times a consistent read was requested for a block from buffer cache. This is a subset of 'consistent gets' statistics value.";
dbStatDefs["CPU used by this session"]="Amount of CPU time (in 10s of milliseconds) used by a session from the time a user call starts until it ends. If a user call completes within 10 milliseconds, the start and end user-call time are the same for purposes of this statistics, and 0 milliseconds are added.A similar problem can exist in the reporting by the operating system, especially on systems that suffer from many context switches.";
dbStatDefs["CPU used when call started"]="The CPU time used when the call is startedSee Also: 'CPU used by this session'";
dbStatDefs["CR blocks created"]="Number of CURRENT blocks cloned to create CR (consistent read) blocks. The most common reason for cloning is that the buffer is held in a incompatible mode.";
dbStatDefs["current blocks converted for CR"]="Number CURRENT blocks converted to CR state";
dbStatDefs["cursor authentications"]="Number of privilege checks conducted during execution of an operation";
dbStatDefs["data blocks consistent reads - undo records applied"]="Number of undo records applied to data blocks that have been rolled back for consistent read purposes";
dbStatDefs["db block changes"]="Closely related to 'consistent changes', this statistic counts the total number of changes that were part of an update or delete operation that were made to all blocks in the SGA. Such changes generate redo log entries and hence become permanent changes to the database if the transaction is committed.This approximates total database work. It statistic indicates the rate at which buffers are being dirtied (on a per-transaction or per-second basis, for example).";
dbStatDefs["db block gets"]="Number of times a CURRENT block was requestedSee Also: 'consistent gets'";
dbStatDefs["db block gets direct"]="Number of times a CURRENT block was requested bypassing the buffer cache (for example, a direct load operation). This is a subset of 'db block gets' statistics value.";
dbStatDefs["db block gets from cache"]="Number of times a CURRENT block was requested from the buffer cache. This is a subset of 'db block gets' statistics value.";
dbStatDefs["DBWR buffers scanned"]="Total number of dirty and clean buffers Oracle looks at when scanning LRU sets for dirty buffers to clean. Divide by 'DBWR lru scans' to find the average number of buffers scanned.";
dbStatDefs["DBWR checkpoint buffers written"]="Number of buffers that were written for checkpoints";
dbStatDefs["DBWR checkpoints"]="Number of times the DBWR was asked to scan the cache and write all blocks marked for a checkpoint or the end of recovery. This statistic is always larger than 'background checkpoints completed'.";
dbStatDefs["DBWR cross instance writes"]="Real Application Clusters only: Number of blocks written to satisfy a lock request from another instance";
dbStatDefs["DBWR free buffers found"]="Number of clean buffers that DBWR found when it was requested to make free buffers. Divide by 'DBWR make free requests' to find the average number of reusable buffers at the end of each LRU.";
dbStatDefs["DBWR lru scans"]="Number of times that DBWR scans the LRU queue looking for buffers to write. This count includes scans to fill a batch being written for another purpose (such as a checkpoint). This statistic is always greater than or equal to 'DBWR make free requests'.";
dbStatDefs["DBWR make free requests"]="Number of requests to DBWR to make some free buffers for the LRU";
dbStatDefs["DBWR revisited being-written buffer"]="Number of times that DBWR tried to save a buffer for writing and found that it was already in the write batch. This statistic measures the amount of 'useless' work that DBWR had to do in trying to fill the batch.Many sources contribute to a write batch. If the same buffer from different sources is considered for adding to the write batch, then all but the first attempt will be 'useless' because the buffer is already marked as being written.";
dbStatDefs["DBWR summed scan depth"]="The current scan depth (number of buffers examined by DBWR) is added to this statistic every time DBWR scans the LRU for dirty buffers. Divide by 'DBWR lru scans' to find the average scan depth.";
dbStatDefs["DBWR transaction table writes"]="Number of rollback segment headers written by DBWR. This statistic indicates how many 'hot' buffers were written, causing a user process to wait while the write completed.";
dbStatDefs["DBWR undo block writes"]="Number of rollback segment blocks written by DBWR";
dbStatDefs["DDL statements parallelized"]="Number of DDL statements that were executed in parallel";
dbStatDefs["deferred (CURRENT) block cleanout applications"]="Number of times cleanout records are deferred, piggyback with changes, always current get";
dbStatDefs["DFO trees parallelized"]="Number of times a serial execution plan was converted to a parallel plan";
dbStatDefs["dirty buffers inspected"]="Number of dirty buffers found by the user process while the it is looking for a buffer to reuse";
dbStatDefs["DML statements parallelized"]="Number of DML statements that were executed in parallel";
dbStatDefs["enqueue conversions"]="Total number of conversions of the state of table or row lock";
dbStatDefs["enqueue deadlocks"]="Total number of deadlocks between table or row locks in different sessions";
dbStatDefs["enqueue releases"]="Total number of table or row locks released";
dbStatDefs["enqueue requests"]="Total number of table or row locks acquired";
dbStatDefs["enqueue timeouts"]="Total number of table and row locks (acquired and converted) that timed out before they could complete";
dbStatDefs["enqueue waits"]="Total number of waits that occurred during an enqueue convert or get because the enqueue get was deferred";
dbStatDefs["exchange deadlocks"]="Number of times that a process detected a potential deadlock when exchanging two buffers and raised an internal, restartable error. Index scans are the only operations that perform exchanges.";
dbStatDefs["execute count"]="Total number of calls (user and recursive) that executed SQL statements";
dbStatDefs["flashback log write bytes"]="Total size in bytes of flashback database data written by RVWR to flashback database logs";
dbStatDefs["flashback log writes"]="Total number of writes by RVWR to flashback database logs";
dbStatDefs["free buffer inspected"]="Number of buffers skipped over from the end of an LRU queue in order to find a reusable buffer. The difference between this statistic and 'dirty buffers inspected' is the number of buffers that could not be used because they had a user, a waiter, or were being read or written, or because they were busy or needed to be written after rapid aging out.";
dbStatDefs["free buffer requested"]="Number of times a reusable buffer or a free buffer was requested to create or load a block";
dbStatDefs["global cache blocks corrupt"]="Real Application Clusters only: Number of blocks that encountered a corruption or checksum failure during interconnect";
dbStatDefs["global cache convert time"]="Real Application Clusters only: Total time elapsed during lock converts";
dbStatDefs["global cache convert timeouts"]="Number of times lock converts in the global cache timed out";
dbStatDefs["global cache converts"]="Number of lock converts in the global cache";
dbStatDefs["global cache cr block log flushes"]="Number of log flushes of the consistent-read block";
dbStatDefs["global cache cr block log flush time"]="Total time spent by the BSP process in log flushes after sending a constructed consistent-read (CR) block. This statistic divided by 'global cache cr blocks served' = log flush time per CR block.";
dbStatDefs["global cache cr block receive time"]="Total amount of time foreground processes waited for a CR block to be sent through the interconnect. This statistic divided by 'global cache cr blocks received' = time waited per block.";
dbStatDefs["global cache cr block send time"]="Total time spent by the BSP process in sending constructed consistent-read (CR) blocks. This statistic divided by 'global cache cr blocks served' = send time per CR block.";
dbStatDefs["global cache cr block serve time"]="Total amount of time the BSP process took to construct consistent-read (CR) blocks. This statistic divided by 'global cache cr blocks served' = construction time per CR block.";
dbStatDefs["global cache cr blocks received"]="Total number of blocks received";
dbStatDefs["global cache cr blocks served"]="Total number of blocks constructed by the BSP process";
dbStatDefs["global cache cr requests blocked"]="Number of times foreground attempt to request a cr block and failed";
dbStatDefs["global cache cr timeouts"]="Number of times a foreground process requested a consistent-read (CR) block when the request timed out";
dbStatDefs["global cache defers"]="Number of times a lock was requested and the holder of the lock deferred the release";
dbStatDefs["global cache freelist waits"]="System configured with fewer lock elements than buffers. Number of times foreground has to wait for a lock element.";
dbStatDefs["global cache get time"]="Total time spent waiting. This divided by global cache gets = time waited per request.";
dbStatDefs["global cache gets"]="Number of locks acquired";
dbStatDefs["global cache prepare failures"]="Number of times a failure occurred during preparation for interconnect transfer";
dbStatDefs["global lock async converts"]="Total number of asynchronous global lock converts";
dbStatDefs["global lock async gets"]="Total number of asynchronous global lock gets";
dbStatDefs["global lock convert time"]="Total elapsed time in 10s of milliseconds of all synchronous and asynchronous global lock converts";
dbStatDefs["global lock get time"]="Total elapsed time in 10s of milliseconds of all synchronous and asynchronous global lock gets";
dbStatDefs["global lock releases"]="Total number of synchronous global lock releases";
dbStatDefs["global lock sync converts"]="Total number of synchronous global lock converts";
dbStatDefs["global lock sync gets"]="Total number of synchronous global lock gets";
dbStatDefs["hot buffers moved to head of LRU"]="When a hot buffer reaches the tail of its replacement list, Oracle moves it back to the head of the list to keep it from being reused. This statistic counts such moves.";
dbStatDefs["immediate (CR) block cleanout applications"]="Number of times cleanout records are applied immediately during consistent-read requests";
dbStatDefs["immediate (CURRENT) block cleanout applications"]="Number of times cleanout records are applied immediately during current gets. Compare this statistic with 'deferred (CURRENT) block cleanout applications'";
dbStatDefs["index fast full scans (direct read)"]="Number of fast full scans initiated using direct read";
dbStatDefs["index fast full scans (full)"]="Number of fast full scans initiated for full segments";
dbStatDefs["index fast full scans (rowid ranges)"]="Number of fast full scans initiated with rowid endpoints specified";
dbStatDefs["instance recovery database freeze count"]="Number of times the database is frozen during instance recovery";
dbStatDefs["kcmccs called get current scn"]="Number of times the kernel got the CURRENT SCN when there was a need to casually confirm the SCN";
dbStatDefs["kcmgss read scn without going to DLM"]="Number of times the kernel got a snapshot SCN without going to the distributed lock manager (DLM)";
dbStatDefs["kcmgss waited for batching"]="Number of times a database process is blocked waiting for a snapshot SCN";
dbStatDefs["leaf node splits"]="Number of times an index leaf node was split because of the insertion of an additional value";
dbStatDefs["lob reads"]="Number of LOB API read operations performed in the session/system. A single LOB API read may correspond to multiple physical/logical disk block reads.";
dbStatDefs["lob writes"]="Number of LOB API write operations performed in the session/system. A single LOB API write may correspond to multiple physical/logical disk block writes.";
dbStatDefs["lob writes unaligned"]="Number of LOB API write operations whose start offset or buffer size is not aligned to the internal chunk size of the LOB. Writes aligned to chunk boundaries are the most efficient write operations. The internal chunk size of a LOB is available through the LOB API (for example, DBMS_LOB.GETCHUNKSIZE()).";
dbStatDefs["logons cumulative"]="Total number of logons since the instance started. Useful only in V$SYSSTAT. It gives an instance overview of all processes that logged on.";
dbStatDefs["logons current"]="Total number of current logons. Useful only in V$SYSSTAT.";
dbStatDefs["messages received"]="Number of messages sent and received between background processes";
dbStatDefs["messages sent"]="Number of messages sent and received between background processes";
dbStatDefs["native hash arithmetic execute"]="Number of hash operations performed using native arithmetic rather than Oracle NUMBERs";
dbStatDefs["native hash arithmetic fail"]="Number of has operations performed using native arithmetic that failed, requiring the hash operation to be performed with Oracle NUMBERs";
dbStatDefs["next scns gotten without going to DLM"]="Number of system change numbers obtained without going to the distributed lock manager or server";
dbStatDefs["no buffer to keep pinned count"]="Number of times a visit to a buffer attempted, but the buffer was not found where expected. Like 'buffer is not pinned count' and 'buffer is pinned count', this statistic is useful only for internal debugging purposes.";
dbStatDefs["no work - consistent read gets"]="Number consistent gets that require neither block cleanouts nor rollbacks.See Also: 'consistent gets'";
dbStatDefs["opened cursors cumulative"]="In V$SYSSTAT: Total number of cursors opened since the instance started.In V$SESSTAT: Total number of cursors opened since the start of the session.";
dbStatDefs["opened cursors current"]="Total number of current open cursors";
dbStatDefs["opens of replaced files"]="Total number of files that had to be reopened because they were no longer in the process file cache";
dbStatDefs["opens requiring cache replacement"]="Total number of file opens that caused a current file in the process file cache to be closed";
dbStatDefs["OS All other sleep time"]="Time spent sleeping for reasons other than misses in the data segment (see 'OS Data page fault sleep time'), kernel page faults (see 'OS Kernel page fault sleep time'), misses in the text segment (see 'OS Text page fault sleep time'), or waiting for an OS locking object (see 'OS User lock wait sleep time'). An example of such a reason is expiration of quanta.";
dbStatDefs["OS Chars read and written"]="Number of bytes read and written";
dbStatDefs["OS Data page fault sleep time"]="Time spent sleeping due to misses in the data segment";
dbStatDefs["OS Input blocks"]="Number of read I/Os";
dbStatDefs["OS Involuntary context switches"]="Number of context switches that were enforced by the operating system";
dbStatDefs["OS Kernel page fault sleep time"]="Time spent sleeping due to OS kernel page faults";
dbStatDefs["OS Major page faults"]="Number of page faults that resulted in I/O";
dbStatDefs["OS Messages received"]="Number of messages received";
dbStatDefs["OS Messages sent"]="Number of messages sent";
dbStatDefs["OS Minor page faults"]="Number of page faults that did not result in an actual I/O";
dbStatDefs["OS Other system trap CPU time"]="Total amount of time to process system traps (as distinct from system calls)";
dbStatDefs["OS Output blocks"]="Number of write I/Os";
dbStatDefs["OS Process heap size"]="Size of area in memory allocated by the process. Typically this represents memory obtained by way of malloc().";
dbStatDefs["OS Process stack size"]="Size of the process stack segment";
dbStatDefs["OS Signals received"]="Number of signals received";
dbStatDefs["OS Swaps"]="Number of swap pages";
dbStatDefs["OS System call CPU time"]="Total amount of time spent executing in system mode";
dbStatDefs["OS System calls"]="Number of system calls";
dbStatDefs["OS Text page fault sleep time"]="Time spent sleeping due to misses in the text segment";
dbStatDefs["OS User level CPU time"]="Total amount of time spent executing in user mode";
dbStatDefs["OS User lock wait sleep time"]="Total amount of time sleeping while waiting for an OS locking object";
dbStatDefs["OS Voluntary context switches"]="Number of voluntary context switches (for example, when a process gives up the CPU by a SLEEP() system call)";
dbStatDefs["OS Wait-cpu (latency) time"]="Time spent sleeping while waiting for a CPU to become available";
dbStatDefs["Parallel operations downgraded 1 to 25 pct"]="Number of times parallel execution was requested and the degree of parallelism was reduced because of insufficient parallel execution servers";
dbStatDefs["Parallel operations downgraded 25 to 50 pct"]="Number of times parallel execution was requested and the degree of parallelism was reduced because of insufficient parallel execution servers";
dbStatDefs["Parallel operations downgraded 50 to 75 pct"]="Number of times parallel execution was requested and the degree of parallelism was reduced because of insufficient parallel execution servers";
dbStatDefs["Parallel operations downgraded 75 to 99 pct"]="Number of times parallel execution was requested and the degree of parallelism was reduced because of insufficient parallel execution servers";
dbStatDefs["Parallel operations downgraded to serial"]="Number of times parallel execution was requested but execution was serial because of insufficient parallel execution servers";
dbStatDefs["Parallel operations not downgraded"]="Number of times parallel execution was executed at the requested degree of parallelism";
dbStatDefs["parse count (hard)"]="Total number of parse calls (real parses). A hard parse is a very expensive operation in terms of memory use, because it requires Oracle to allocate a workheap and other memory structures and then build a parse tree.";
dbStatDefs["parse count (total)"]="Total number of parse calls (hard and soft). A soft parse is a check on an object already in the shared pool, to verify that the permissions on the underlying object have not changed.";
dbStatDefs["parse time cpu"]="Total CPU time used for parsing (hard and soft) in 10s of milliseconds";
dbStatDefs["parse time elapsed"]="Total elapsed time for parsing, in 10s of milliseconds. Subtract 'parse time cpu' from the this statistic to determine the total waiting time for parse resources.";
dbStatDefs["physical read bytes"]="Total size in bytes of all disk reads by application activity (and not other instance activity) only.";
dbStatDefs["physical read IO requests"]="Number of read requests for application activity (mainly buffer cache and direct load operation) which read one or more database blocks per request. This is a subset of 'physical read total IO requests' statistic.";
dbStatDefs["physical read total bytes"]="Total size in bytes of disk reads by all database instance activity including application reads, backup and recovery, and other utilities. The difference between this value and 'physical read bytes' gives the total read size in bytes by non-application workload.";
dbStatDefs["physical read total IO requests"]="Number of read requests which read one or more database blocks for all instance activity including application, backup and recovery, and other utilities. The difference between this value and 'physical read total multi block requests' gives the total number of single block read requests.";
dbStatDefs["physical read total multi block requests"]="Total number of Oracle instance read requests which read in two or more database blocks per request for all instance activity including application, backup and recovery, and other utilities.";
dbStatDefs["physical reads"]="Total number of data blocks read from disk. This value can be greater than the value of 'physical reads direct' plus 'physical reads cache' as reads into process private buffers also included in this statistic.";
dbStatDefs["physical reads cache"]="Total number of data blocks read from disk into the buffer cache. This is a subset of 'physical reads' statistic.";
dbStatDefs["physical reads direct"]="Number of reads directly from disk, bypassing the buffer cache. For example, in high bandwidth, data-intensive operations such as parallel query, reads of disk blocks bypass the buffer cache to maximize transfer rates and to prevent the premature aging of shared data blocks resident in the buffer cache.";
dbStatDefs["physical reads for flashback new"]="Number of blocks read for newing (that is, preparing a data block for a completely new change) blocks while flashback database is enabled";
dbStatDefs["physical reads prefetch warmup"]="Number of data blocks that were read from the disk during the automatic prewarming of the buffer cache.";
dbStatDefs["physical write bytes"]="Total size in bytes of all disk writes from the database application activity (and not other kinds of instance activity).";
dbStatDefs["physical write IO requests"]="Number of write requests for application activity (mainly buffer cache and direct load operation) which wrote one or more database blocks per request.";
dbStatDefs["physical write total bytes"]="Total size in bytes of all disk writes for the database instance including application activity, backup and recovery, and other utilities. The difference between this value and 'physical write bytes' gives the total write size in bytes by non-application workload.";
dbStatDefs["physical write total IO requests"]="Number of write requests which wrote one or more database blocks from all instance activity including application activity, backup and recovery, and other utilities. The difference between this stat and 'physical write total multi block requests' gives the number of single block write requests.";
dbStatDefs["physical write total multi block requests"]="Total number of Oracle instance write requests which wrote two or more blocks per request to the disk for all instance activity including application activity, recovery and backup, and other utilities.";
dbStatDefs["physical writes"]="Total number of data blocks written to disk. This statistics value equals the sum of 'physical writes direct' and 'physical writes from cache' values.";
dbStatDefs["physical writes direct"]="Number of writes directly to disk, bypassing the buffer cache (as in a direct load operation)";
dbStatDefs["physical writes from cache"]="Total number of data blocks written to disk from the buffer cache. This is a subset of 'physical writes' statistic.";
dbStatDefs["physical writes non checkpoint"]="Number of times a buffer is written for reasons other than advancement of the checkpoint. Used as a metric for determining the I/O overhead imposed by setting the FAST_START_IO_TARGET parameter to limit recovery I/Os. (Note that FAST_START_IO_TARGET is a deprecated parameter.) Essentially this statistic measures the number of writes that would have occurred had there been no checkpointing. Subtracting this value from 'physical writes' gives the extra I/O for checkpointing.";
dbStatDefs["pinned buffers inspected"]="Number of times a user process, when scanning the tail of the replacement list looking for a buffer to reuse, encountered a cold buffer that was pinned or had a waiter that was about to pin it. This occurrence is uncommon, because a cold buffer should not be pinned very often.";
dbStatDefs["prefetched blocks"]="Number of contiguous and noncontiguous blocks that were prefetched";
dbStatDefs["prefetched blocks aged out before use"]="Number of contiguous and noncontiguous blocks that were prefetched but aged out before use";
dbStatDefs["process last non-idle time"]="The last time this process executed";
dbStatDefs["PX local messages recv'd"]="Number of local messages received for parallel execution within the instance local to the current session";
dbStatDefs["PX local messages sent"]="Number of local messages sent for parallel execution within the instance local to the current session";
dbStatDefs["PX remote messages recv'd"]="Number of remote messages received for parallel execution within the instance local to the current session";
dbStatDefs["PX remote messages sent"]="Number of remote messages sent for parallel execution within the instance local to the current session";
dbStatDefs["queries parallelized"]="Number of SELECT statements executed in parallel";
dbStatDefs["recovery array read time"]="Elapsed time of I/O during recovery";
dbStatDefs["recovery array reads"]="Number of reads performed during recovery";
dbStatDefs["recovery blocks read"]="Number of blocks read during recovery";
dbStatDefs["recovery blocks read for lost write detection"]="Number of blocks read for lost write checks during recovery.";
dbStatDefs["recovery blocks skipped lost write checks"]="Number of Block Read Records that skipped the lost write check during recovery.";
dbStatDefs["recursive calls"]="Number of recursive calls generated at both the user and system level. Oracle maintains tables used for internal processing. When Oracle needs to make a change to these tables, it internally generates an internal SQL statement, which in turn generates a recursive call.";
dbStatDefs["recursive cpu usage"]="Total CPU time used by non-user calls (recursive calls). Subtract this value from 'CPU used by this session' to determine how much CPU time was used by the user calls.";
dbStatDefs["redo blocks checksummed by FG (exclusive)"]="Number of exclusive redo blocks that were checksummed by the generating foreground processes. An exclusive redo block is the one whose entire redo content belongs to a single redo entry.";
dbStatDefs["redo blocks checksummed by LGWR"]="Number of redo blocks that were checksummed by the LGWR.";
dbStatDefs["redo blocks written"]="Total number of redo blocks written. This statistic divided by 'redo writes' equals number of blocks per write.";
dbStatDefs["redo buffer allocation retries"]="Total number of retries necessary to allocate space in the redo buffer. Retries are needed either because the redo writer has fallen behind or because an event such as a log switch is occurring.";
dbStatDefs["redo entries"]="Number of times a redo entry is copied into the redo log buffer";
dbStatDefs["redo entries for lost write detection"]="Number of times a Block Read Record is copied into the log buffer.";
dbStatDefs["redo log space requests"]="Number of times the active log file is full and Oracle must wait for disk space to be allocated for the redo log entries. Such space is created by performing a log switch.Log files that are small in relation to the size of the SGA or the commit rate of the work load can cause problems. When the log switch occurs, Oracle must ensure that all committed dirty buffers are written to disk before switching to a new log file. If you have a large SGA full of dirty buffers and small redo log files, a log switch must wait for DBWR to write dirty buffers to disk before continuing.Also examine the log file space and log file space switch wait events in V$SESSION_WAIT";
dbStatDefs["redo log space wait time"]="Total elapsed waiting time for 'redo log space requests' in 10s of milliseconds";
dbStatDefs["redo ordering marks"]="Number of times that a system change number was allocated to force a redo record to have a higher SCN than a record generated in another thread using the same block";
dbStatDefs["redo size"]="Total amount of redo generated in bytes";
dbStatDefs["redo size for lost write detection"]="Total amount of Block Read Records generated in bytes.";
dbStatDefs["redo synch time"]="Elapsed time of all 'redo synch writes' calls in 10s of milliseconds";
dbStatDefs["redo synch writes"]="Number of times a change being applied to the log buffer must be written out to disk due to a commit. The log buffer is a circular buffer that LGWR periodically flushes. Usually, redo that is generated and copied into the log buffer need not be flushed out to disk immediately.";
dbStatDefs["redo wastage"]="Number of bytes wasted because redo blocks needed to be written before they are completely full. Early writing may be needed to commit transactions, to be able to write a database buffer, or to switch logs.";
dbStatDefs["redo write broadcast ack count"]="Number of times a commit broadcast acknowledgment has not been received by the time when the corresponding log write is completed. This is only for Oracle RAC.";
dbStatDefs["redo write broadcast ack time"]="Total amount of the latency associated with broadcast on commit beyond the latency of the log write (in microseconds). This is only for Oracle RAC.";
dbStatDefs["redo write time"]="Total elapsed time of the write from the redo log buffer to the current redo log file in 10s of milliseconds";
dbStatDefs["redo writes"]="Total number of writes by LGWR to the redo log files. 'redo blocks written' divided by this statistic equals the number of blocks per write";
dbStatDefs["remote instance undo block writes"]="Number of times this instance wrote a rollback segment so that another instance could read it";
dbStatDefs["remote instance undo header writes"]="Number of times this instance wrote a undo header block so that another instance could read it";
dbStatDefs["rollback changes - undo records applied"]="Number of undo records applied to user-requested rollback changes (not consistent-read rollbacks)";
dbStatDefs["rollbacks only - consistent read gets"]="Number of consistent gets that require only block rollbacks, no block cleanouts.See Also: 'consistent gets'";
dbStatDefs["rows fetched via callback"]="Rows fetched via callback. Useful primarily for internal debugging purposes.";
dbStatDefs["serializable aborts"]="Number of times a SQL statement in a serializable isolation level had to abort";
dbStatDefs["session connect time"]="The connect time for the session in 10s of milliseconds. This value is useful only in V$SESSTAT. It is the wall clock time since the logon to this session occurred.";
dbStatDefs["session cursor cache count"]="Total number of cursors cached. This statistic is incremented only if SESSION_CACHED_CURSORS > 0. This statistic is the most useful in V$SESSTAT. If the value for this statistic in V$SESSTAT is close to the setting of the SESSION_CACHED_CURSORS parameter, the value of the parameter should be increased.";
dbStatDefs["session cursor cache hits"]="Number of hits in the session cursor cache. A hit means that the SQL statement did not have to be reparsed. Subtract this statistic from 'parse count (total)' to determine the real number of parses that occurred.";
dbStatDefs["session logical reads"]="The sum of 'db block gets' plus 'consistent gets'. This includes logical reads of database blocks from either the buffer cache or process private memory.";
dbStatDefs["session pga memory"]="Current PGA size for the session. Useful only in V$SESSTAT; it has no meaning in V$SYSSTAT.";
dbStatDefs["session pga memory max"]="Peak PGA size for the session. Useful only in V$SESSTAT; it has no meaning in V$SYSSTAT.";
dbStatDefs["session stored procedure space"]="Amount of memory this session is using for stored procedures";
dbStatDefs["session uga memory"]="Current UGA size for the session. Useful only in V$SESSTAT; it has no meaning in V$SYSSTAT.";
dbStatDefs["session uga memory max"]="Peak UGA size for a session. Useful only in V$SESSTAT; it has no meaning in V$SYSSTAT.";
dbStatDefs["shared io pool buffer get failure"]="Number of unsuccessful buffer gets from the shared I/O pool from instance startup time.";
dbStatDefs["shared io pool buffer get success"]="Number of successful buffer gets from the shared I/O pool from instance startup time.";
dbStatDefs["sorts (disk)"]="Number of sort operations that required at least one disk writeSorts that require I/O to disk are quite resource intensive. Try increasing the size of the initialization parameter SORT_AREA_SIZE. For more information, see 'SORT_AREA_SIZE'.";
dbStatDefs["sorts (memory)"]="Number of sort operations that were performed completely in memory and did not require any disk writesYou cannot do much better than memory sorts, except maybe no sorts at all. Sorting is usually caused by selection criteria specifications within table join SQL operations.";
dbStatDefs["sorts (rows)"]="Total number of rows sorted";
dbStatDefs["SQL*Net roundtrips to/from client"]="Total number of Oracle Net Services messages sent to and received from the client";
dbStatDefs["SQL*Net roundtrips to/from dblink"]="Total number of Oracle Net Services messages sent over and received from a database link";
dbStatDefs["summed dirty queue length"]="The sum of the dirty LRU queue length after every write request. Divide by write requests to get the average queue length after write completion.";
dbStatDefs["switch current to new buffer"]="Number of times the CURRENT block moved to a different buffer, leaving a CR block in the original buffer";
dbStatDefs["table fetch by rowid"]="Number of rows that are fetched using a ROWID (usually recovered from an index)This occurrence of table scans usually indicates either non-optimal queries or tables without indexes. Therefore, this statistic should increase as you optimize queries and provide indexes in the application.";
dbStatDefs["table fetch continued row"]="Number of times a chained or migrated row is encountered during a fetchRetrieving rows that span more than one block increases the logical I/O by a factor that corresponds to the number of blocks than need to be accessed. Exporting and re-importing may eliminate this problem. Evaluate the settings for the storage parameters PCTFREE and PCTUSED. This problem cannot be fixed if rows are larger than database blocks (for example, if the LONG datatype is used and the rows are extremely large).";
dbStatDefs["table scan blocks gotten"]="During scanning operations, each row is retrieved sequentially by Oracle. This statistic counts the number of blocks encountered during the scan.This statistic tells you the number of database blocks that you had to get from the buffer cache for the purpose of scanning. Compare this value with the value of 'consistent gets' to determine how much of the consistent read activity can be attributed to scanning.";
dbStatDefs["table scan rows gotten"]="Number of rows that are processed during scanning operations";
dbStatDefs["table scans (cache partitions)"]="Number of range scans performed on tables that have the CACHE option enabled";
dbStatDefs["table scans (direct read)"]="Number of table scans performed with direct read (bypassing the buffer cache)";
dbStatDefs["table scans (long tables)"]="Long (or conversely short) tables can be defined as tables that do not meet the short table criteria as described in table scans (short tables)";
dbStatDefs["table scans (rowid ranges)"]="During parallel query, the number of table scans conducted with specified ROWID ranges";
dbStatDefs["table scans (short tables)"]="Long (or conversely short) tables can be defined by optimizer hints coming down into the row source access layer of Oracle. The table must have the CACHE option set.";
dbStatDefs["total file opens"]="Total number of file opens performed by the instance. Each process needs a number of files (control file, log file, database file) in order to work against the database.";
dbStatDefs["transaction lock background get time"]="Useful only for internal debugging purposes";
dbStatDefs["transaction lock background gets"]="Useful only for internal debugging purposes";
dbStatDefs["transaction lock foreground requests"]="Useful only for internal debugging purposes";
dbStatDefs["transaction lock foreground wait time"]="Useful only for internal debugging purposes";
dbStatDefs["transaction rollbacks"]="Number of transactions being successfully rolled back";
dbStatDefs["transaction tables consistent read rollbacks"]="Number of times rollback segment headers are rolled back to create consistent read blocks";
dbStatDefs["transaction tables consistent reads - undo records applied"]="Number of undo records applied to transaction tables that have been rolled back for consistent read purposes";
dbStatDefs["Unnecessary process cleanup for SCN batching"]="Total number of times that the process cleanup was performed unnecessarily because the session or process did not get the next batched SCN. The next batched SCN went to another session instead.";
dbStatDefs["user calls"]="Number of user calls such as login, parse, fetch, or executeWhen determining activity, the ratio of user calls to RPI calls, give you an indication of how much internal work gets generated as a result of the type of requests the user is sending to Oracle.";
dbStatDefs["user commits"]="Number of user commits. When a user commits a transaction, the redo generated that reflects the changes made to database blocks must be written to disk. Commits often represent the closest thing to a user transaction rate.";
dbStatDefs["user rollbacks"]="Number of times users manually issue the ROLLBACK statement or an error occurs during a user's transactions";
dbStatDefs["write clones created in background"]="Number of times a background or foreground process clones a CURRENT buffer that is being written. The clone becomes the new, accessible CURRENT buffer, leaving the original buffer (now the clone) to complete writing.";
dbStatDefs["write clones created in foreground"]="Number of times a background or foreground process clones a CURRENT buffer that is being written. The clone becomes the new, accessible CURRENT buffer, leaving the original buffer (now the clone) to complete writing.";
dbStatDefs["cell flash cache read hits"]="Number of read requests that were a cache hit on exadata flash cache.";
dbStatDefs["cell IO uncompressed bytes"]="The total size of uncompressed data that is processed on the cell. For scan on hybrid-columnar-compressed tables, this statistic is the size of data after decompression.";
dbStatDefs["cell physical IO interconnect bytes returned by smart scan"]="The number of bytes that are returned by the cell for Smart Scan only, and does not include bytes for other database I/O.";
dbStatDefs["cell physical IO bytes saved by storage index"]="The number of bytes saved by storage index.";
dbStatDefs["cell physical IO bytes eligible for predicate offload"]="The total number of I/O bytes processed with physical disks when processing was offloaded to the cell.";
dbStatDefs["cell physical IO bytes saved during optimized file creation"]="The number of I/O bytes saved by the database host by offloading the file creation operation to cells. This statistic shows the Exadata Cell benefit due to optimized file creation operations.";
dbStatDefs["cell physical IO bytes saved during optimized RMAN file restore"]="The number of I/O bytes saved by the database host by offloading the RMAN file restore operation to cells. This statistic shows the Exadata Cell benefit due to optimized RMAN file restore operations.";
dbStatDefs["cell physical IO interconnect bytes"]="The number of I/O bytes exchanged over the interconnection between the database host and cells.";
dbStatDefs["physical read requests optimized"]="Total number of read requests satisfied either by using Exadata Smart Flash Cache or storage index.";
dbStatDefs["physical read total bytes"]="Total amount of I/O bytes for reads processed with physical disks. This includes when processing was offloaded to the cell and when processing was not offloaded.";
dbStatDefs["physical read total bytes optimized"]="Total number of bytes read from Exadata Smart Flash Cache or storage index.";
dbStatDefs["physical write total bytes"]="Total amount of I/O bytes for writes processed with physical disks. This includes when processing was offloaded to the cell and when processing was not offloaded.";
var dbWaitDefs = new Array();

dbWaitDefs["alter system set dispatcher"]="A session has issued a statement ALTER SYSTEM SET DISPATCHER = string and is waiting for the dispatchers to get started.<p><span class='bold'>Wait Time:</span> The session will wait 1 / 100 of a second and check to see if the new dispatchers have started else the session will wait again</p>";
dbWaitDefs["batched allocate scn lock request"]="A session is waiting on another process to allocate a system change number (SCN). If the foreground timed out waiting on a process to get the SCN, the foreground will get the SCN.<p><span class='bold'>Wait Time:</span> The wait time is 1 second on the assumption that an SCN allocation should normally need much less than that</p>";
dbWaitDefs["BFILE check if exists"]="The session waits to check if an external large object (LOB) exists.<p><span class='bold'>Wait Time:</span> The total elapsed time for the <span class='bold'>exists</span> call</p>";
dbWaitDefs["BFILE check if open"]="The session waits for an external large object (LOB) to open.<p><span class='bold'>Wait Time:</span> The total elapsed time for the <span class='bold'>isopen</span> call</p>";
dbWaitDefs["BFILE closure"]="The session waits for an external large object (LOB) to close.<p><span class='bold'>Wait Time:</span> The total elapsed time for the <span class='bold'>close</span> call</p>";
dbWaitDefs["BFILE get length"]="The session waits on a call to check the size of an external large object (LOB).<p><span class='bold'>Wait Time:</span> The total elapsed time for the call to check the LOB size</p>";
dbWaitDefs["BFILE get name object"]="The session waits on a call to find or generate the external name of a external large object.<p><span class='bold'>Wait Time:</span> The total elapse time for <span class='bold'>make external file name</span> to complete</p>";
dbWaitDefs["BFILE get path object"]="The session is waiting on a call to find or generate the external path name of an external large object (LOB).<p><span class='bold'>Wait Time:</span> The total elapsed time for <span class='bold'>make external path</span> to complete</p>";
dbWaitDefs["BFILE internal seek"]="The session waits for a positioning call within the external large object (LOB) to complete.<p><span class='bold'>Wait Time:</span> The total elapse time for the <span class='bold'>seek</span> to complete</p>";
dbWaitDefs["BFILE open"]="The session waits for an external large object (LOB) to open.<p><span class='bold'>Wait Time:</span> The total elapsed time for the <span class='bold'>isopen</span> call</p>";
dbWaitDefs["BFILE read"]="The session waits for a read from a external large object (LOB) to complete.<p><span class='bold'>Wait Time:</span> The total elapse time for the <span class='bold'>read</span> to complete</p>";
dbWaitDefs["broadcast mesg queue transition"]="Processes enter 'wait for broadcast mesg queue transition' when cleaning up a publisher channel handle to a RELIABLE broadcast channel. The publisher is responsible for moving the message to the free queue, but it cannot do so until the message is in the done queue. If the message is still not in the done queue, process enters this wait. This wait event will most likely show up when an Oracle process is about to exit normally, or when PMON cleans up a dead process.<p><span class='bold'>Wait Time:</span> Varies</p>";
dbWaitDefs["broadcast mesg recovery queue transition"]="Processes enter 'wait for broadcast mesg recovery queue transition' when cleaning up a publisher channel handle to a RELIABLE broadcast channel. The broadcasted message is in the recovery queue of another channel handle (for example, ch2). Process enters this wait, if the message is yet to be removed from the recovery queue of the ch2 channel handle. This wait event will most likely show up when an Oracle process is about to exit normally, or when PMON cleans up a dead process.<p><span class='bold'>Wait Time:</span> Varies</p>";
dbWaitDefs["buffer busy waits"]="Wait until a buffer becomes available. This event happens because a buffer is either being read into the buffer cache by another session (and the session is waiting for that read to complete) or the buffer is the buffer cache, but in a incompatible mode (that is, some other session is changing the buffer).<p><span class='bold'>Wait Time:</span> Normal wait time is 1 second. If the session was waiting for a buffer during the last wait, then the next wait will be 3 seconds.</p>";
dbWaitDefs["buffer deadlock"]="Oracle does not really wait on this event; the foreground only yields the CPU. Thus, the chances of catching this event are very low. This is not an application induced deadlock, but an assumed deadlock by the cache layer. The cache layer cannot get a buffer in a certain mode within a certain amount of time.<p><span class='bold'>Wait Time:</span> 0 seconds. The foreground process only yields the CPU and will usually be placed at the end of the CPU run queue.</p>";
dbWaitDefs["buffer latch"]="The session waits on the buffer hash chain latch. Primarily used in the dump routines.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["buffer read retry"]="This event occurs only if the instance is mounted in shared mode (Oracle Real Application Cluster). During the read of the buffer, the contents changed. This means that either:<p>The version number, dba, or the incarnation and sequence number stored in the block no longer match</p>";
dbWaitDefs["checkpoint completed"]="A session waits for a checkpoint to complete. This could happen, for example, during a close database or a local checkpoint.<p><span class='bold'>Wait Time:</span> 5 seconds</p>";
dbWaitDefs["cleanup of aborted processes"]="When a process spawn is aborted while the process spawning background is in the middle of spawning, the current session must wait until the pid of the new process is filled in. Once the pid is filled in, then the process spawn can be actually aborted.<p><span class='bold'>Wait Time:</span> Usually 3 seconds</p>";
dbWaitDefs["control file parallel write"]="This event occurs while the session is writing physical blocks to all control files. This happens when:<p>The session starts a control file transaction (to make sure that the control files are up to date in case the session crashes before committing the control file transaction)</p>";
dbWaitDefs["control file sequential read"]="Reading from the control file. This happens in many cases. For example, while:<p>Making a backup of the control files</p>";
dbWaitDefs["control file single write"]="This wait is signaled while the control file's shared information is written to disk. This is an atomic operation protected by an enqueue (CF), so that only one session at a time can write to the entire database.<p><span class='bold'>Wait Time:</span> The wait time is the elapsed time of the write</p>";
dbWaitDefs["cursor: mutex S"]="A session waits on this event when it is requesting a mutex in shared mode, when another session is currently holding a this mutex in exclusive mode on the same cursor object.";
dbWaitDefs["cursor: mutex X"]="The session requests the mutex for a cursor object in exclusive mode, and it must wait because the resource is busy. The mutex is busy because either the mutex is being held in exclusive mode by another session or the mutex is being held shared by one or more sessions. The existing mutex holder(s) must release the mutex before the mutex can be granted exclusively.";
dbWaitDefs["cursor: pin S"]="A session waits on this event when it wants to update a shared mutex pin and another session is currently in the process of updating a shared mutex pin for the same cursor object.  This wait event should rarely be seen because a shared mutex pin update is very fast.<p><span class='bold'>Wait Time:</span> Microseconds</p>";
dbWaitDefs["cursor: pin S wait on X"]="A session waits for this event when it is requesting a shared mutex pin and another session is holding an exclusive mutex pin on the same cursor object.<p><span class='bold'>Wait Time:</span> Microseconds</p>";
dbWaitDefs["cursor: pin X"]="A session waits on this event when it is requesting an exclusive mutex pin for a cursor object and it must wait because the resource is busy. The mutex pin for a cursor object can be busy either because a session is already holding it exclusive, or there are one or more sessions which are holding shared mutex pin(s). The exclusive waiter must wait until all holders of the pin for that cursor object have released it, before it can be granted.<p><span class='bold'>Wait Time:</span> Microseconds</p>";
dbWaitDefs["Data Guard: process clean up"]="During Data Guard process termination, Data Guard will wait for one second for process cleanup to complete.";
dbWaitDefs["Data Guard: process exit"]="During Data Guard process termination, Data Guard will wait for a process to exit before attempting any process cleanup that may be required.  It will sleep for one second between each check for process exit.";
dbWaitDefs["Data Guard Broker: single instance"]="The Data Guard Broker (DMON) process waits for the other instances in this cluster to complete shutdown before continuing with the broker operation.<p><span class='bold'>Wait Time:</span> Depends on the number of instances, but not exceeding 30 seconds times the number of instances</p>";
dbWaitDefs["db file parallel read"]="This happens during recovery. It can also happen during buffer prefetching, as an optimization (rather than performing multiple single-block reads). Database blocks that need to be changed as part of recovery are read in parallel from the database.<p><span class='bold'>Wait Time:</span> Wait until all of the I/Os are completed</p>";
dbWaitDefs["db file parallel write"]="This event occurs in the DBWR. It indicates that the DBWR is performing a parallel write to files and blocks. When the last I/O has gone to disk, the wait ends.<p><span class='bold'>Wait Time:</span> Wait until all of the I/Os are completed</p>";
dbWaitDefs["db file scattered read"]="Similar to db file sequential read, except that the session is reading multiple data blocks.<p><span class='bold'>Wait Time:</span> The wait time is the actual time it takes to do all of the I/Os</p>";
dbWaitDefs["db file sequential read"]="The session waits while a sequential read from the database is performed. This event is also used for rebuilding the control file, dumping datafile headers, and getting the database file headers.<p><span class='bold'>Wait Time:</span> The wait time is the actual time it takes to do the I/O</p>";
dbWaitDefs["db file single write"]="This event is used to wait for the writing of the file headers.<p><span class='bold'>Wait Time:</span> The wait time is the actual time it takes to do the I/O</p>";
dbWaitDefs["DFS db file lock"]="This event occurs only for the DBWR in Real Application Clusters. Each DBWR of every instance holds a global lock on each file in shared mode. The instance that is trying to offline the file will escalate the global lock from shared to exclusive. This signals the other instances to synchronize their SGAs with the control file before the file can be taken offline. The name of this lock is DF (see Appendix D, 'Oracle Enqueue Names' for more information).<p><span class='bold'>Wait Time:</span> 1 second in loop. The DBWR is waiting in a loop (sleep, check) for the other instances to downgrade to NULL mode. During this time, the DBWR cannot perform other tasks such as writing buffers.</p>";
dbWaitDefs["DFS lock handle"]="The session waits for the lock handle of a global lock request. The lock handle identifies a global lock. With this lock handle, other operations can be performed on this global lock (to identify the global lock in future operations such as conversions or release). The global lock is maintained by the DLM.<p><span class='bold'>Wait Time:</span> The session waits in a loop until it has obtained the lock handle from the DLM. Inside the loop there is a wait of 0.5 seconds.</p>";
dbWaitDefs["direct path read"]="During Direct Path operations the data is asynchronously read from the database files. At some stage the session needs to make sure that all outstanding asynchronous I/O have been completed to disk. This can also happen if during a direct read no more slots are available to store outstanding load requests (a load request could consist of multiple I/Os).<p><span class='bold'>Wait Time:</span> 10 seconds. The session will be posted by the completing asynchronous I/O. It will never wait the entire 10 seconds. The session waits in a tight loop until all outstanding I/Os have completed.</p>";
dbWaitDefs["direct path write"]="During Direct Path operations, the data is asynchronously written to the database files. At some stage the session needs to make sure that all outstanding asynchronous I/O have been completed to disk. This can also happen if, during a direct write, no more slots are available to store outstanding load requests (a load request could consist of multiple I/Os).<p><span class='bold'>Wait Time:</span> 10 seconds. The session will be posted by the completing asynchronous I/O. It will never wait the entire 10 seconds. The session waits in a tight loop until all outstanding I/Os have completed.</p>";
dbWaitDefs["dispatcher shutdown"]="During shutdown immediate or normal, the shutdown process must wait for all the dispatchers to shutdown. As each dispatcher is signaled, the session that causes the shutdown is waits on this event until the requested dispatcher is no longer alive.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["dispatcher timer"]="This basically means that the dispatcher is idle and waiting for some work to arrive.<p><span class='bold'>Wait Time:</span> 60 seconds</p>";
dbWaitDefs["duplicate cluster key"]="It is possible for a race condition to occur when creating a new cluster key. If it is found that another process has put the cluster key into the data/index block, then the session waits and retries. The retry should then find a valid cluster key.<p><span class='bold'>Wait Time:</span> 0.01 seconds</p>";
dbWaitDefs["enq: OW - initialization"]="A session will wait on this event if it is trying to initialize the database wallet, and another session has already begun an initialization.<p><span class='bold'>Wait Time:</span> Total time necessary to initialize the wallet context</p>";
dbWaitDefs["enq: OW - termination"]="A session will wait on this event if it is trying to terminate the database wallet, and another session has already begun a termination.<p><span class='bold'>Wait Time:</span> Total time necessary to deallocate memory used by the wallet context and terminate the context.</p>";
dbWaitDefs["enqueue"]="The session is waiting for a local enqueue. The wait is dependent on the name of the enqueue (see Appendix D, 'Oracle Enqueue Names').<p><span class='bold'>Wait Time:</span> Depends on the enqueue name</p>";
dbWaitDefs["flashback buf free by RVWR"]="This wait event only occurs when Flashback Database is turned on. A session waits for recovery writer (RVWR) to write flashback data to the flashback logs on disk because the buffers are full. Until RVWR can free up the buffers, the session may need to wait.<p>If this event becomes a top wait event for the database, it is typically because the file system or storage system for the Flash Recovery Area does not support enough bandwidth for Oracle to write the flashback database logs. Refer to the Flashback Database section in <a class='olink BRADV' href='../../backup.112/e10642/toc.htm'><span class='italic'>Oracle Database Backup and Recovery User&#39;s Guide</span></a> <a class='olink BRADV' href='../../backup.112/e10642/toc.htm'></a>for tuning considerations.</p>";
dbWaitDefs["flashback logfile sync"]="Waits for flashback database data to be written to disk.<p><span class='bold'>Wait Time:</span> Includes RVWR writing the flashback database data and posting this process</p>";
dbWaitDefs["free buffer waits"]="This will happen if:<p>All buffer gets have been suspended. This could happen when a file was read-only and is now read-write. All the existing buffers need to be invalidated since they are not linked to lock elements (needed when mounted parallel (shared)). So cache buffers are not assigned to data block addresses until the invalidation is finished.</p>";
dbWaitDefs["free global transaction table entry"]="The session is waiting for a free slot in the global transaction table (used by the Distributed Database option). It will wait for 1 second and try again.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["free process state object"]="Used during the creation of a process. The session will scan the process table and look for a free process slot. If none can be found, PMON is posted to check if all the processes currently in the process table are still alive. If there are dead processes, then PMON will clean them and make the process slot available to new processes. The waiting process will then rescan the process table to find the new slot.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["GCS lock open S"]="The session waits for a resource get in SHARED mode on the block identified by file# and block#.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["GCS lock open X"]="The session waits for a resource get in EXCLUSIVE mode on the block identified by file# and block#.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["gcs remastering wait for drop pkey"]="A session dropping an object waits on the lock manager daemon (LMD) to remove the object's affinity to an instance.<p>Wait Time: 20 hundredths of a second</p>";
dbWaitDefs["global cache busy"]="The session waits to convert a buffer from Shared Current to Exclusive Current status.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["global cache lock cleanup"]="PMON is waiting for an LCK process to cleanup the lock context after a foreground process died while doing a global cache lock operation.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["global cache freelist"]="All releasable locks are used and a new one has been requested. To make a resource element available, a resource element is pinged.<p><span class='bold'>Wait Time:</span> The duration of the resource get operation to ping the resource element</p>";
dbWaitDefs["inactive session"]="This event is used for two purposes:<p>Switching sessions</p>";
dbWaitDefs["inactive transaction branch"]="The session waits for a transaction branch that is currently used by another session.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["index block split"]="While trying to find an index key in an index block, Oracle noticed that the index block was being split. Oracle will wait for the split to finish and try to find the key again.<p><span class='bold'>Wait Time:</span> The session will yield the CPU, so there is no actual waiting time</p>";
dbWaitDefs["instance state change"]="The session waits for SMON to enable or disable cache or transaction recovery. This usually happens during ALTER DATABASE OPEN or CLOSE.<p><span class='bold'>Wait Time:</span> Wait time depends on the amount of time the action takes (that is, the amount of recovery needed)</p>";
dbWaitDefs["io done"]="The session waits for an I/O to complete or it waits for a slave process to become available to submit the I/O request. This event occurs on platforms that do not support asynchronous I/O.<p><span class='bold'>Wait Time:</span> 50 milliseconds</p>";
dbWaitDefs["kcl bg acks"]="The session waits for the background LCK process(es) to finish what they are doing. For example:<p>Lock recovery</p>";
dbWaitDefs["ksxr wait for mount shared"]="The cross instance broadcast facility of this Oracle instance is waiting for the database mount in shared mode to complete.<p><span class='bold'>Wait Time:</span> The time taken for the instance to mount. An indefinite wait on this event implies that the instance startup is hanging.</p>";
dbWaitDefs["ktm: instance recovery"]="The session waits for SMON to finish the instance, transaction recovery, or sort segment cleanup.<p><span class='bold'>Wait Time:</span> The wait time can vary and depends on the amount of recovery needed</p>";
dbWaitDefs["latch activity"]="This event is used as part of the process of determining whether a latch needs to be cleaned.<p><span class='bold'>Wait Time:</span> 0.05 to 0.1 seconds</p>";
dbWaitDefs["latch free"]="The process waits for a latch that is currently busy (held by another process).<p><span class='bold'>Wait Time:</span> The wait time increases exponentially and does not include spinning on the latch (active waiting). The maximum wait time also depends on the number of latches that the process is holding. There is an incremental wait of up to 2 seconds.</p>";
dbWaitDefs["library cache load lock"]="The session tries to find the load lock for the database object so that it can load the object. The load lock is always obtained in Exclusive mode, so that no other process can load the same object. If the load lock is busy the session will wait on this event until the lock becomes available.<p><span class='bold'>Wait Time:</span> 3 seconds (1 second for PMON)</p>";
dbWaitDefs["library cache lock"]="This event controls the concurrency between clients of the library cache. It acquires a lock on the object handle so that either:<p>One client can prevent other clients from accessing the same object</p>";
dbWaitDefs["library cache pin"]="This event manages library cache concurrency. Pinning an object causes the heaps to be loaded into memory. If a client wants to modify or examine the object, the client must acquire a pin after the lock.<p><span class='bold'>Wait Time:</span> 3 seconds (1 second for PMON)</p>";
dbWaitDefs["library cache shutdown"]="The process shutting down the instance waits for sessions to complete before proceeding with library cache shutdown.";
dbWaitDefs["LMON global data update"]="The rolling migration operation is waiting for a response from LMON to acknowledge the global data was updated.<p><span class='bold'>Wait Time:</span> The time it takes for LMON to publish/retrieve the global data associated with a</p>";
dbWaitDefs["lock manager wait for remote message"]="The lock manager waits for a message from a remote lock manager in the same configuration.<p><span class='bold'>Wait Time:</span> The elapsed time of the wait</p>";
dbWaitDefs["Log archive I/O"]="Used local archiving of online redo logs (for a production database) or standby redo logs (for a standby database). When the archiving process exhausts its I/O buffers because all of them are being used for on-going I/O's, the wait for an available I/O buffer is captured in this system wait event.<p><span class='bold'>Wait Time:</span> Depends on the speed of the disks</p>";
dbWaitDefs["log buffer space"]="Waiting for space in the log buffer because the session is writing data into the log buffer faster than LGWR can write it out. Consider making the log buffer bigger if it is small, or moving the log files to faster disks such as striped disks.<p><span class='bold'>Wait Time:</span> Usually 1 second, but 5 seconds if it is waiting for a Switch Logfile to complete</p>";
dbWaitDefs["log file parallel write"]="Writing redo records to the redo log files from the log buffer.<p><span class='bold'>Wait Time:</span> Time it takes for the I/Os to complete. Even though redo records are written in parallel, the parallel write is not complete until the last I/O is on disk.</p>";
dbWaitDefs["log file sequential read"]="Waiting for the read from this logfile to return. This is used to read redo records from the log file.<p><span class='bold'>Wait Time:</span> Time it takes to complete the physical I/O (read)</p>";
dbWaitDefs["log file single write"]="Waiting for the write to this logfile to complete. This event is used while updating the header of the logfile. It is signaled when adding a log file member and when incrementing sequence numbers.<p><span class='bold'>Wait Time:</span> Time it takes for the physical I/O (write) to complete</p>";
dbWaitDefs["log file switch (archiving needed)"]="Waiting for a log switch because the log that the LGWR will be switching into has not been archived yet. Check the alert file to make sure that archiving has not stopped due to a failed archive write. To speed archiving, consider adding more archive processes or putting the archive files on striped disks.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["log file switch (checkpoint incomplete)"]="Waiting for a log switch because the session cannot wrap into the next log. Wrapping cannot be performed because the checkpoint for that log has not completed.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["log file switch (clearing log file)"]="Waiting for a log switch because the log is being cleared due to a CLEAR LOGFILE command or implicit clear logfile executed by recovery.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["log file switch (private strand flush incomplete)"]="User sessions trying to generate redo, wait on this event when LGWR waits for DBWR to complete flushing redo from IMU buffers into the log buffer; when DBWR is complete LGWR can then finish writing the current log, and then switch log files.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["log file switch completion"]="Waiting for a log switch to complete.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["log file sync"]="When a user session commits, the session's redo information needs to be flushed to the redo logfile. The user session will post the LGWR to write the log buffer to the redo log file. When the LGWR has finished writing, it will post the user session.<p><span class='bold'>Wait Time:</span> The wait time includes the writing of the log buffer and the post.</p>";
dbWaitDefs["log switch/archive"]="Used as part of the ALTER SYSTEM ARCHIVE LOG CHANGE scn statement. The session waits for the current log from all open threads to be archived.<p><span class='bold'>Wait Time:</span> Wait for up to 10 seconds</p>";
dbWaitDefs["optimizer stats update retry"]="When concurrent sessions try to update optimizer statistics for the same object, all of them except the one that successfully acquired all necessary locks/pins on the library/row cache entries, wait on this wait event and then retry locking after a short period of time. In addition to explicit statistics gathering and maintenance operations using the DBMS_STATS package, Oracle database itself may try to update statistics for some objects, either on behalf of the user or for its own maintenance purposes.<p><span class='bold'>Wait Time:</span> 10 ms</p>";
dbWaitDefs["parallel recovery change buffer free"]="The parallel recovery coordinator is waiting for a change mapping buffer to be released by one of the recovery slaves.<p><span class='bold'>Wait Time:</span> 100ms</p>";
dbWaitDefs["parallel recovery control message reply"]="The parallel recovery coordinator is waiting for all recovery slaves to respond to a synchronous control message.<p><span class='bold'>Wait Time:</span> 100ms</p>";
dbWaitDefs["parallel recovery coord send blocked"]="The parallel recovery coordinator is unable to send a redo change message because the recovery slave is still actively applying redo that it has already received and has not yet released the channel.<p><span class='bold'>Wait Time:</span> 100ms</p>";
dbWaitDefs["parallel recovery coord wait for reply"]="The parallel recovery coordinator is waiting for all recovery slaves to exit.<p><span class='bold'>Wait Time:</span> 100ms</p>";
dbWaitDefs["parallel recovery coordinator waits for slave cleanup"]="The parallel recovery coordinator is waiting for all recovery slaves to exit gracefully.<p><span class='bold'>Wait Time:</span> 10ms</p>";
dbWaitDefs["parallel recovery read buffer free"]="The parallel recovery coordinator is waiting for a log read buffer to be released by all recovery slaves. Only after every recovery slave finishes applying redo from a log read buffer, can the buffer be used by the coordinator to issue the next log read.<p><span class='bold'>Wait Time:</span> 100ms</p>";
dbWaitDefs["parallel recovery slave next change"]="A parallel recovery slave is idle and waiting for the next change message from the coordinator.<p><span class='bold'>Wait Time:</span> 100ms</p>";
dbWaitDefs["pending global transaction(s)"]="This event should happen only during testing. The session waits for pending transactions to clear.<p><span class='bold'>Wait Time:</span> 30 seconds</p>";
dbWaitDefs["pipe get"]="The session waits for a message to be received on the pipe or for the pipe timer to expire.<p><span class='bold'>Wait Time:</span> There is a 5 second wake up (check) and the pipe timer set by the user</p>";
dbWaitDefs["pipe put"]="The session waits for the pipe send timer to expire or for space to be made available in the pipe.<p><span class='bold'>Wait Time:</span> There is the 5 second wakeup (check) and the user-supplied timeout value</p>";
dbWaitDefs["PL/SQL lock timer"]="This event is called through the DBMS_LOCK.SLEEP procedure or USER_LOCK.SLEEP procedure. This event will most likely originate from procedures written by a user.<p><span class='bold'>Wait Time:</span> The wait time is in hundredths of seconds and is dependent on the user context</p>";
dbWaitDefs["pmon timer"]="This is the main wait event for PMON. When PMON is idle, it is waiting on this event.<p><span class='bold'>Wait Time:</span> Up to 3 seconds, if not posted before</p>";
dbWaitDefs["prewarm transfer retry"]="Release a hash latch, then wait under this event before attempting to re-acquire the hash latch.<p><span class='bold'>Wait Time:</span> 10ms</p>";
dbWaitDefs["prior process spawner to be cleaned up"]="When a prior process has died while spawning a background, the current process which is trying to spawn new a background must wait until the prior process state is cleaned up.<p><span class='bold'>Wait Time:</span> Usually 3 - 10 seconds</p>";
dbWaitDefs["process startup"]="Wait for a shared server, Dispatcher, or other background process to start.<p><span class='bold'>Wait Time:</span> Wait up to 1 second for a background process to start. If timed out, then re-wait until 5 minutes have passed and signal an error. If the process has started, the event will acknowledge this.</p>";
dbWaitDefs["PX Deque wait"]="The process is waiting for a message during a parallel execute.<p><span class='bold'>Wait Time:</span> The wait time depends on how quickly the message arrives. Wait times can vary, but it will normally be a short period of time.</p>";
dbWaitDefs["PX qref latch"]="Each parallel execution process has a parallel execution qref latch, which needs to be acquired before the queue buffers can be manipulated.<p><span class='bold'>Wait Time:</span> Wait up to 1 second</p>";
dbWaitDefs["PX server shutdown"]="During normal or immediate shutdown the parallel execution slaves are posted to shutdown cleanly. If any parallel execution slaves are still alive after 10 seconds, they are killed.<p><span class='bold'>Wait Time:</span> Wait up to 0.5 seconds</p>";
dbWaitDefs["PX signal server"]="This event occurs only in Exclusive mode. The query coordinator is signalling the Query Slaves that an error has occurred.<p><span class='bold'>Wait Time:</span> 0.5 seconds</p>";
dbWaitDefs["Streams AQ: waiting for messages in the queue"]="The session is waiting on an empty OLTP queue (Advanced Queuing) for a message to arrive so that the session can dequeue that message.<p><span class='bold'>Wait Time:</span> The amount of time that the session wants to wait is determined by the parameter <span class='italic'>wait time</span></p>";
dbWaitDefs["rdbms ipc message"]="The background processes (LGWR, DBWR, LMS0) use this event to indicate that they are idle and are waiting for the foreground processes to send them an IPC message to do some work.<p><span class='bold'>Wait Time:</span> Up to 3 seconds. The parameter <span class='italic'>timeout</span> shows the true sleep time.</p>";
dbWaitDefs["rdbms ipc message block"]="This event indicates that all message blocks are in use and that the session had to wait for a message block to become available.<p><span class='bold'>Wait Time:</span> Wait up to 60 seconds</p>";
dbWaitDefs["rdbms ipc reply"]="This event is used to wait for a reply from one of the background processes.<p><span class='bold'>Wait Time:</span> The wait time is specified by the user and is indicated by the parameter <span class='italic'>timeout</span>.</p>";
dbWaitDefs["read by other session"]="This event occurs when a session requests a buffer that is currently being read into the buffer cache by another session. Prior to release 10.1, waits for this event were grouped with the other reasons for waiting for buffers under the 'buffer busy wait' event<p><span class='bold'>Wait Time:</span> Time waited for the buffer to be read by the other session (in microseconds)</p>";
dbWaitDefs["recovery read"]="A parallel recovery slave (or serial recovery process) is waiting for a batch of data block reads to complete.<p><span class='bold'>Wait Time:</span> Time it takes to complete the physical I/O (read)</p>";
dbWaitDefs["resmgr: become active"]="The session is waiting for a resource manager active session slot. This event occurs when the resource manager is enabled and the number of active sessions in the session's current consumer group exceeds the current resource plan's active session limit for the consumer group. To reduce the occurrence of this wait event, increase the active session limit for the session's current consumer group.<p><span class='bold'>Wait Time:</span> The time the session waited to be allocated an active session slot</p>";
dbWaitDefs["resmgr: cpu quantum"]="The session is waiting to be allocated a quantum of cpu. This event occurs when the resource manager is enabled and is throttling CPU consumption. To reduce the occurrence of this wait event, increase the CPU allocation for the sessions's current consumer group.<p>Wait Time: The time the session waited to acquire a CPU quantum</p>";
dbWaitDefs["rolling migration: cluster quisce"]="This is the wait event that instances wait on when cluster is about to start a rolling migration. The instances are waiting for any privileged operations that blocks rolling migration to complete before allowing rolling migration.<p>Wait Time: 1 second</p>";
dbWaitDefs["row cache lock"]="The session is trying to get a data dictionary lock.<p><span class='bold'>Wait Time:</span> Wait up to 60 seconds.</p>";
dbWaitDefs["RVWR wait for flashback copy"]="Waits for a process to copy flashback database data into the flashback buffer, in order to write out the requested flashback data.<p><span class='bold'>Wait TIme:</span> 10 miliseconds</p>";
dbWaitDefs["sbtbufinfo"]="This function is called when Oracle needs to discover the size, and number, of I/O buffers that have been allocated by the SBT layer.  It should be very fast and never block.<p><span class='bold'>Wait Time:</span> Less than one millisecond</p>";
dbWaitDefs["sbtgetbuf"]="This function obtains one I/O buffer that Oracle will use for I/O during a backup job.<p><span class='bold'>Wait Time:</span> Less than one millisecond</p>";
dbWaitDefs["sbtmapbuf"]="This is an internal function used to facilitate multi-process buffer management.  It should be very fast and never block.<p><span class='bold'>Wait Time:</span> Less than one millisecond</p>";
dbWaitDefs["sbtrelbuf"]="This function releases an I/O buffer that has been already processed during a restore job, so that the SBT layer can fill it with more data.  It should be very fast and never block.<p><span class='bold'>Wait Time:</span> Less than one millisecond</p>";
dbWaitDefs["scginq AST call"]="Called by the session to find the highest lock mode that is held on a resource.<p><span class='bold'>Wait Time:</span> Wait up to 0.2 seconds, but the wait will continue until the NULL mode Acquisition AST has fired.</p>";
dbWaitDefs["SGA: allocation forcing component growth"]="Process waiting on an immediate mode memory transfer with auto-tune SGA after a 4031 for MMAN to get the memory and post it.<p><span class='bold'>Wait Time:</span> 10 msec</p>";
dbWaitDefs["SGA: MMAN sleep for component shrink"]="MMAN to wait and post itself for satisfying an auto-tuned memory request while trying to fully free a component's quiesced granules. In Release 10.1, the name of this event was 'wait for SGA component shrink'.<p><span class='bold'>Wait Time:</span> 10 msec</p>";
dbWaitDefs["SGA: sga_target resize"]="Memory resize requests wait while sga target is being resized.In Release 10.1, the name of this event was 'wait for sga_target resize'.<p><span class='bold'>Wait Time:</span> 10 msec</p>";
dbWaitDefs["Shared IO Pool Memory"]="Wait until a shared I/O pool buffer becomes available. This happens when processes are using these buffers for I/O and the current process needs to wait for the release of any one of the buffers to the shared I/O pool.<p><span class='bold'>Wait Time:</span> 10msec</p>";
dbWaitDefs["single-task message"]="When running single task, this event indicates that the session waits for the client side of the executable.<p><span class='bold'>Wait Time:</span> Total elapsed time that this session spent in the user application</p>";
dbWaitDefs["shared server idle wait"]="Idle wait event for a shared server. The server waits on the common queue for a virtual circuit. (See also 'virtual circuit wait'.)<p><span class='bold'>Wait Time:</span> 30 seconds</p>";
dbWaitDefs["smon timer"]="This is the main idle event for SMON. SMON will be waiting on this event most of the time until it times out or is posted by another process.<p><span class='bold'>Wait Time:</span> 5 minutes (300 seconds)</p>";
dbWaitDefs["SQL*Net break/reset to client"]="The server sends a break or reset message to the client. The session running on the server waits for a reply from the client.<p><span class='bold'>Wait Time:</span> The actual time it takes for the break or reset message to return from the client</p>";
dbWaitDefs["SQL*Net break/reset to dblink"]="Same as SQL*Net break/reset to client, but in this case, the break/reset message is sent to another server process over a database link.<p><span class='bold'>Wait Time:</span> The actual time it takes for the break or reset message to return from the other server process</p>";
dbWaitDefs["SQL*Net message from client"]="The server process (foreground process) waits for a message from the client process to arrive.<p><span class='bold'>Wait Time:</span> The time it took for a message to arrive from the client since the last message was sent to the client</p>";
dbWaitDefs["SQL*Net message from dblink"]="The session waits while the server process (foreground process) receives messages over a database link from another server process.<p><span class='bold'>Wait Time:</span> The time it took for a message to arrive from another server (foreground process) since a message was sent to the other foreground process.</p>";
dbWaitDefs["SQL*Net message to client"]="The server (foreground process) is sending a message to the client.<p><span class='bold'>Wait Time:</span> The actual time the <span class='bold'>send</span> takes</p>";
dbWaitDefs["SQL*Net message to dblink"]="The server process (foreground process) is sending a message over a database link to another server process.<p><span class='bold'>Wait Time:</span> The actual time the <span class='bold'>send</span> takes</p>";
dbWaitDefs["SQL*Net more data from client"]="The server is waiting on the client to send more data to its client shadow process, in an already initiated operation.<p><span class='bold'>Wait Time:</span> The time waited depends on the time it took to receive the data (including the waiting time)</p>";
dbWaitDefs["SQL*Net more data from dblink"]="The foreground process is expecting more data from a data base link.<p><span class='bold'>Wait Time:</span> The total time it takes to read the data from the database link (including the waiting time for the data to arrive)</p>";
dbWaitDefs["SQL*Net more data to client"]="The server process is sending more data/messages to the client. The previous operation to the client was also a send.<p><span class='bold'>Wait Time:</span> The actual time it took for the <span class='bold'>send</span> to complete</p>";
dbWaitDefs["SQL*Net more data to dblink"]="The event indicates that the server is sending data over a database link again. The previous operation over this database link was also a send.<p><span class='bold'>Wait Time:</span> The actual time it takes to send the data to the other server</p>";
dbWaitDefs["switch logfile command"]="The session waits on the user command SWITCH LOGFILE to complete.<p><span class='bold'>Wait Time:</span> 5 seconds</p>";
dbWaitDefs["TCP Socket (KGAS)"]="A session is waiting for an external host to provide requested data over a network socket. The time that this wait event tracks does not indicate a problem, and even a long wait time is not a reason to contact Oracle Support. It naturally takes time for data to flow between hosts over a network, and for the remote aspect of an application to process any request made to it. An application that communicates with a remote host must wait until the data it will read has arrived. In addition, on Microsoft Windows, a separate thread monitors the arrival of traffic. This thread spends most of its life in waits tracked by the TCP Socket (KGAS) wait event.<p><span class='bold'>Wait Time:</span> The total elapsed time for the network connection to be established or for data to arrive from over the network</p>";
dbWaitDefs["timer in sksawat"]="The session waits for the Archiver (ARCH) asynchronous I/O to complete.<p><span class='bold'>Wait Time:</span> 0.01 seconds</p>";
dbWaitDefs["transaction"]="Wait for a blocking transaction to be rolled back. Continue waiting until the transaction has been rolled back.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["unbound tx"]="The session waits to see if there are any transactions that have been started but do not have a Rollback Segment associated with them.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["undo_retention publish retry"]="This wait can occur for two reasons.  A session issuing an ALTER SYSTEM SET UNDO_RETENTION may wait on this event wait while a cluster reconfiguration takes place.  Or the background process MMNL may wait for cluster reconfiguration while attempting to determine the max UNDO_RETENTION.<p><span class='bold'>Wait time:</span> 1 second</p>";
dbWaitDefs["undo segment extension"]="The undo segment is being extended or shrunk. The session must wait until the operation on the undo segment has finished.<p><span class='bold'>Wait Time:</span> 0.01 seconds</p>";
dbWaitDefs["undo segment recovery"]="PMON is rolling back a dead transaction. The wait continues until rollback finishes.<p><span class='bold'>Wait Time:</span> 3 seconds</p>";
dbWaitDefs["undo segment tx slot"]="Wait for a transaction slot to become available within the selected rollback segment. Continue waiting until the slot is available.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["virtual circuit status"]="The session waits for a virtual circuit to return a message type indicated by status.<p><span class='bold'>Wait Time:</span> 30 seconds</p>";
dbWaitDefs["virtual circuit wait"]="The session waits for a virtual circuit operation to complete.<p><span class='bold'>Wait Time:</span> 30 seconds</p>";
dbWaitDefs["WCR: replay client notify"]="During replay, the Workload Replay Client always keeps an open connection to the database to detect some special errors. This session will normally be in the wait state until some specific replay-related exception occurs.<p><span class='bold'>Wait Time:</span> Waits until notified. Times out every 30 seconds.</p>";
dbWaitDefs["WCR: replay clock"]="A session will wait on this event during replay if it has some logical dependencies on another session that has not yet committed its work.<p><span class='bold'>Wait Time:</span> Depends upon the amount of row lock contention in the original capture</p>";
dbWaitDefs["WCR: replay lock order"]="A session will wait on this event during replay if it saw some lock contention during capture.<p><span class='bold'>Wait Time:</span> Depends upon the amount of row lock contention in the original capture</p>";
dbWaitDefs["WCR: replay paused"]="When the user issues a DBMS_WORKLOAD_REPLAY.PAUSE_REPLAY command, all the replayed sessions are waiting on this wait event until replay is resumed.<p><span class='bold'>Parameters:</span> None</p>";
dbWaitDefs["WCR: Sync context busy"]="In the default replay mode, commits during replay are synchronized to follow the same order as capture. All commits are serialized using the Sync context. A replayed session will wait on this event if it is trying to commit at the same time as another replayed session.<p><span class='bold'>Parameters:</span> None</p>";
dbWaitDefs["WMON goes to sleep"]="WMON is the UNIX-specific Wait Monitor, that can be used to reduce the number of system calls related to setting timers for posting or waiting in Oracle. You need to set an initialization parameter that enables the WMON process.<p><span class='bold'>Wait Time:</span> Depends on the next timeout</p>";
dbWaitDefs["write complete waits"]="The session waits for a buffer to be written. The write is caused by normal aging or by a cross-instance call.<p><span class='bold'>Wait Time:</span> 1 second</p>";
dbWaitDefs["writes stopped by instance recovery or database suspension"]="The session is blocked until the instance that started Instance Recovery is finished.<p><span class='bold'>Wait Time:</span> 5 seconds</p>";

// RAC related waits which are not documented in original version
dbWaitDefs["gc buffer busy acquire"]="Event gc buffer busy event means that a session is trying to access a buffer,but there is an open request for Global cache lock for that block already, and so, the session must wait for the GC lock request to complete before proceeding. This wait is instrumented as gc buffer busy event. <br> If existing GC open request originated from the local instance, then current session will wait for gc buffer busy acquire. Essentially, current process is waiting for another process in the local instance to acquire GC lock, on behalf of the local instance. Once GC lock is acquired, current process can access that buffer without additional GC processing (if the lock is acquired in a compatible mode).<br>For RHS index growth you see GC Buffer Busy Acquire/Release and GC Buffer Busy events and gc current request for the same block. <br> f the block is on instance 1 all other sessions from instance 1 are waiting on gc buffer busy aquire whereas sessions on the other instances are waiting on gc buffer busy release.";
dbWaitDefs["gc buffer busy release"]="Event gc buffer busy event means that a session is trying to access a buffer,but there is an open request for Global cache lock for that block already, and so, the session must wait for the GC lock request to complete before proceeding. This wait is instrumented as gc buffer busy event. <br> If existing GC open request originated from a remote instance, then current session will wait for gc buffer busy release event. In this case session is waiting for another remote session (hence another instance) to release the GC lock, so that local instance can acquire buffer.";
dbWaitDefs["gc cr block busy"]="Busy events indicate that LMS needs to perform additional work before sending a block ( like apply Redo to build CR block )";
dbWaitDefs["gc current block busy"]="Busy events indicate that LMS needs to perform add. work before sending a block ( like apply Redo to build CR block )";
dbWaitDefs["gc current grant busy"]="Grant is received but there is a delay due to many shared block images or load. For example we are extending the high water mark and we are formatting the block images or blocks with block headers.";
dbWaitDefs["gcs log flush sync"]="In a health database, 90% of waits should be less than 2ms. <br> Before sending a reconstructed CR block or CUR block, LMS will verify that corresponding redo vectors are flushed to disk. <br> LMS will flush request a log flush when there are uncomitted transactions within the required block -> Increasing commit frequence will increase this wait event too. <br> Use lfsdiag.sql script to understand the wait time suffered by LGWR process. <br> If the redo vector are not flushed, LMS on node2 need to wait for ‘gcs log flush sync’ event after requesting LGWR for a log flush, analogous to ‘log file sync’ event. <br> Always check related instances for LOG FILE SYNC event as this event also reduces the Redo I/O bandwith. If gcs log flush sync wait event is significant then you need to understand your LGWR performance";
dbWaitDefs["gc current block 2-way"]="For a Current Block in read mode a KPJUERPR ( Protected Read ) lock is requested. <br>Wait event can occur for READ and WRITE activities. <br>If accessing a locally mastered block on the local instance no GCS lock is needed ( FG can access this block without any GCS support – Affinity locking ).<br> Excessive waits for gc current block are either related to inefficient QEP leading to nummerous block visits or application affinity not being in play.";
dbWaitDefs["gc current block 3-way"]="For a Current Block in read mode a KPJUERPR ( Protected Read ) lock is requested. <br>Wait event can occur for READ and WRITE activities. <br>If accessing a locally mastered block on the local instance no GCS lock is needed ( FG can access this block without any GCS support – Affinity locking ).<br> Excessive waits for gc current block are either related to inefficient QEP leading to nummerous block visits or application affinity not being in play.";
dbWaitDefs["gc cr block 2-way"]="CR block transfers are requested for Read Only access and are specific to a certain session and SQL statment.<br>Next execution of same statement will again trigger this wait event as SCN is increased and CR block needs to be refreshed.<br>No locks are maintained by GCS for CR blocks.<br>Long-pending transaction on highly accessed objects can lead to CR storm ( Run this sort of transactions at a less busy timeframe ).";
dbWaitDefs["gc cr block 3-way"]="CR block transfers are requested for Read Only access and are specific to a certain session and SQL statment.<br>Next execution of same statement will again trigger this wait event as SCN is increased and CR block needs to be refreshed.<br>No locks are maintained by GCS for CR blocks.<br>Long-pending transaction on highly accessed objects can lead to CR storm ( Run this sort of transactions at a less busy timeframe ).";
dbWaitDefs["gc cr grant 2-way"]="If a block is not resident in any buffer cache  LMS grants the FG process to read the block from disk.<br>Excessive waits for gc cr/current 2-way wait event can be caused by a undersize buffer cache or SQL stmt flushing the buffer cache.<br>This sort of messages can be used to measure your Network performance as very less pressing is done for this event.";
dbWaitDefs["gc current grant 2-way"]="If a block is not resident in any buffer cache  LMS grants the FG process to read the block from disk.<br>Excessive waits for gc cr/current 2-way wait event can be caused by a undersize buffer cache or SQL stmt flushing the buffer cache.<br>This sort of messages can be used to measure your Network performance as very less pressing is done for this event.";
dbWaitDefs["gc cr block congested"]="if LMS process did not process a request within 1ms than LMS marks the response to that block with the congestion wait event. Root cause: LMS is suffering CPU scheduling, LMS is suffering resources like memory ( paging ). As LMS processes are RT processes OS scheduling delays should be minimal.";
dbWaitDefs["gc current block congested"]="if LMS process did not process a request within 1ms than LMS marks the response to that block with the congestion wait event. Root cause: LMS is suffering CPU scheduling, LMS is suffering resources like memory ( paging ). As LMS processes are RT processes OS scheduling delays should be minimal.";

// latches
dbWaitDefs["latch: row cache objects"]="check the v$rowcache, the latch is protecting access to dictionary cache. See the number of gets and misses on DC_ objects to find the problem. Look into MOS for possible bugs, hard parsing etc. Look <a href=https://sites.google.com/site/embtdbo/latch-row-cache-objects>here</a>";
dbWaitDefs["latch: cache buffers chains"]="Latch is protecting concurrent access to a buffer. Look for concurrent access to same buffer, also known as hot block. Look for queries fetch lots of rows in deep nested loop join. Check for latch: cache buffer handles also.";
dbWaitDefs["latch: cache buffer handles"]="Every new session gets handles in the private memory as _db_handles_cached for pinning buffers, if the private handles are not sufficient, it goes to global pool of handles which is protected by this latch. A deep nested loop join might need to pin more buffers during the plan traversal. Increasing the _db_handles_cached may help, but before that try to find the queries causing the latch and improve the execution plan if possible."



var osStatDefs = new Array();

osStatDefs["NUM_CPUS"]="Number of CPUs or processors available";
osStatDefs["IDLE_TIME"]="Number of hundredths of a second that a processor has been idle, totalled over all processors";
osStatDefs["BUSY_TIME"]="Number of hundredths of a second that a processor has been busy executing user or kernel code, totalled over all processors";
osStatDefs["USER_TIME"]="Number of hundredths of a second that a processor has been busy executing user code, totalled over all processors";
osStatDefs["SYS_TIME"]="Number of hundredths of a second that a processor has been busy executing kernel code, totalled over all processors";
osStatDefs["IOWAIT_TIME"]="Number of hundredths of a second that a processor has been waiting for I/O to complete, totalled over all processors";
osStatDefs["NICE_TIME"]="Number of hundredths of a second that a processor has been busy executing low-priority user code, totalled over all processors";
osStatDefs["AVG_IDLE_TIME"]="Number of hundredths of a second that a processor has been idle, averaged over all processors";
osStatDefs["AVG_BUSY_TIME"]="Number of hundredths of a second that a processor has been busy executing user or kernel code, averaged over all processors";
osStatDefs["AVG_USER_TIME"]="Number of hundredths of a second that a processor has been busy executing user code, averaged over all processors";
osStatDefs["AVG_SYS_TIME"]="Number of hundredths of a second that a processor has been busy executing kernel code, averaged over all processors";
osStatDefs["AVG_IOWAIT_TIME"]="Number of hundredths of a second that a processor has been waiting for I/O to complete, averaged over all processors";
osStatDefs["AVG_NICE_TIME"]="Number of hundredths of a second that a processor has been busy executing low-priority user code, averaged over all processors";
osStatDefs["OS_CPU_WAIT_TIME"]="Total number of hundredths of a second that processes have been in a ready state, waiting to be selected by the operating system scheduler to run";
osStatDefs["RSRC_MGR_CPU_WAIT_TIME"]="Total number of hundredths of a second that Oracle processes have been in a ready state, waiting for CPU to be available for their consumer group in the currently active resource plan";
osStatDefs["VM_PAGE_IN_BYTES"]="Total number of bytes of data that have been paged in due to virtual memory paging";
osStatDefs["VM_PAGE_OUT_BYTES"]="Total number of bytes of data that have been paged out due to virtual memory paging";
osStatDefs["PHYSICAL_MEMORY_BYTES"]="Total number of bytes of physical memory";
osStatDefs["LOAD"]="Current number of processes that are either running or in the ready state, waiting to be selected by the operating-system scheduler to run. On many platforms, this statistic reflects the average load over the past minute.";
osStatDefs["NUM_CPU_CORES"]="Number of CPU cores available (includes subcores of multicore CPUs as well as single-core CPUs)";
osStatDefs["NUM_CPU_SOCKETS"]="Number of CPU sockets available (represents an absolute count of CPU chips on the system, regardless of multithreading or multi-core architectures)";
osStatDefs["NUM_VCPUS"]="Number of virtual CPUs available";
osStatDefs["NUM_LCPUS"]="Number of logical CPUs available (includes hardware threads if hardware threading is turned on)";
osStatDefs["TCP_SEND_SIZE_MIN"]="Minimum size of the TCP send buffer";
osStatDefs["TCP_SEND_SIZE_DEFAULT"]="Default size of the TCP send buffer";
osStatDefs["TCP_SEND_SIZE_MAX"]="Maximum size of the TCP send buffer";
osStatDefs["TCP_RECEIVE_SIZE_MIN"]="Minimum size of the TCP receive buffer";
osStatDefs["TCP_RECEIVE_SIZE_DEFAULT"]="Default size of the TCP receive buffer";
osStatDefs["TCP_RECEIVE_SIZE_MAX"]="Maximum size of the TCP receive buffer";
osStatDefs["GLOBAL_SEND_SIZE_MAX"]="Maximum size of the global send buffer";
osStatDefs["GLOBAL_RECEIVE_SIZE_MAX"]="Maximum size of the global receive buffer";
